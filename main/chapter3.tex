%!TEX root = ../my_thesis.tex

\renewcommand{\curChapter}{main/chapter3}

\chapter{\AFFECT: A Fast Forward Error Correction Toolbox}
\label{chap:aff3ct}

\vspace*{\fill}
\minitoccustom
\vspace*{\fill}

\newpage
\section{Philosophy}

\AFFECT for \emph{A Fast Forward Error Correction Toolbox} is a set of tools
regrouping all the contributions of this thesis and more. \AFFECT is pronounced
\emph{\textschwa'fekt} like ``affect'' in English. The ``E'' is reversed to a
``3'' and symbolizes a channel error that can be easily corrected. It is also
inspired by the leetspeak to create a proper noun.

\subsection{High Performance Implementations}

\AFFECT is mainly written in \Cxx~\cite{Stroustrup2013}. This choice has been
made to focus on high performance implementations without sacrificing too much
the expressibility. The \Cxx is a compiled language, it allows very low level
programming paradigms like intrinsics functions (or even assembly code) as well
as high level concepts like the Object-Oriented Programming (OOP) paradigm.
Moreover, the \Cxx comes with the template meta-programming technique to
facilitate the programming at compile time. An other main advantage of the \Cxx
is that it is constantly evolving~\cite{Stroustrup2020} and it is well-spread in
the HPC community. We choose to limit the utilization of the \Cxx to its 2011
version (\Cxy{11}). This choice has been made for two main reasons: 1) to
maximize the compatibility with the installed compilers in various environments;
2) the \Cxy{11} features are now largely adopted by the developers community
while the need of the new \Cxx standards is still sometimes questioned.

The signal processing community mainly writes source codes with high level
languages like MATLAB or Python. There is no doubt that these language allows
to write implementations close to the pseudo-code but an important part of the
CPU computational power is wasted. When targeting low error-rate functional
simulations or real-time constraints (like for the Cloud-RAN and the SDR), these
high level languages are not suitable. For the signal processing algorithms
implemented in \AFFECT, we observed that compared to interpreted languages, the
speedups range from 10 to 1000 in \Cxx. And, if we consider the very optimized
implementations presented in Chapter~\ref{chap:opt}, the speedups are closer to
1000.

Of course the speedups are not simply coming from the porting of the MATLAB
code to the \Cxx code. It is true that the compiler is sometime able to perform
optimizations that will benefit for the overall performance, but most of the
speedup comes from dedicated implementations. The \Cxx enables source code
implementations to take advantage of the hardware architecture. And, it is up
to the developer to use its knowledge of the CPU architecture in the development
process. As explained in Chapter~\ref{chap:opt}, optimizations like the
vectorization, the choice of an adapted data layout and the loop unrolling are
the keys of the proposed high performance implementations.

\subsection{Algorithmic Heterogeneity}

As shown in Chapter~\ref{chap:ctx}~and~\ref{chap:opt}, there are many signal
processing algorithms along with many possible implementations. A summary list
of the algorithms supported by \AFFECT will be given in the next section. Thus,
it motivates the need to regroup and package all these algorithms in a common
toolbox. The main interests are 1) to propose common and homogeneous interfaces
to the users and 2) to maximize the code reuse in the implementations.

\MIPP is a perfect example of code reuse as it defines elementary blocks used
everywhere in \AFFECT. But other macro blocks are also ofter reused like the
reordering process proposed in Sections~\ref{sec:opt_vec_inter}. Of course there
are many other macro blocks in \AFFECT similar to the ones that are presented in
the manuscript. This allows to speedup and facilitate the implementation of new
efficient algorithms.

In the context of the channel codes, the algorithmic heterogeneity is
challenging and each family has its own specificities. This is the main reason
why in most of the other existing projects the focus is made on a single code
family (c.f. Section~\ref{sec:aff3ct_related_works}). It strongly motivated
the need of a toolbox like \AFFECT. The objective is to homogenize the use of
various code families. The \AFFECT source code organization is detailed in
Section~\ref{sec:aff3ct_archi}.

\subsection{Portability}

The portability is an other main concern in \AFFECT. Thanks to the \Cxy{11}
standard library, the same \AFFECT source code can be compiled on Windows, macOS
and Linux. It is possible to compile with the GNU compiler (GCC), the Clang
compiler, the Intel\R \Cxx compiler (ICPC) and the Microsoft\R Visual compiler
(MSVC). Note that other operating systems and compilers may also work as long as
they are compatible with the \Cxy{11} standard.

\AFFECT can also take advantage of various common CPU architectures like
Intel\R/AMD\R and ARM\R processors. Thanks to \MIPP (c.f.
Section~\ref{sec:opt_mipp}), the compiled binary is specialized to use the
appropriate SIMD ISA. If the architecture is not recognized then the \AFFECT
binary will fall-back to a sequential version.

The portability is the key to enable the utilization of \AFFECT in various
contexts. We identified some possible use cases: they are presented in
Section~\ref{sec:aff3ct_use_cases}.

\subsection{Reproducible Science}

In the signal processing community it is not common to share the resulting
implementations of a scientific publication. Thus, it is sometime a tedious task
to reproduce the state-of-the-art results and the community spends a
non-negligible amount of time in ``reinventing the wheel''. We think this should
be avoided and \AFFECT is an open source toolbox coming with a permissive MIT
license. This way, industrials and academics actors can invest themselves and
reuse parts of \AFFECT in their own projects without any restrictions. The
general impact of \AFFECT is discussed in Section~\ref{sec:aff3ct_impact}.

Even if the code is fully open, there is no guarantee that the achieved results
can be reproduced as the code is constantly evolving. Any modification of the
source code can break features that were working before. This problem is
inherent to all living projects. To reduce as much as possible the regressions,
a full pipeline of tests has been created and will be detailed in
Section~\ref{sec:aff3ct_ci_cd}. Each time someone makes a modification on the
\AFFECT source code, then the pipeline of tests is triggered.

\section{Related Works}
\label{sec:aff3ct_related_works}

\begin{table}[htp]
  \centering
  \caption{\C/\Cxx open source channel coding simulators/libraries.}
  \label{tab:fec_libraries_comparison}
  % \begin{adjustbox}{angle=90}
  {\resizebox{\linewidth}{!}{
  \begin{tabular}{r   r  r  r  r  r | C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth}  C{\simcolwidth} }
  \multirow{4}{*}{\textbf{Name}} & \multirow{4}{*}{\textbf{Ref.}} &                  &                &                & \multirow{4}{*}{\textbf{License}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Polar}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{LDPC}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Turbo}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Turbo P.}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{BCH}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{RS}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Conv.}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{RA}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Rep.}} & \multirow{4}{*}{\rotatebox[origin=c]{90}{Erasure}} \\
                                 &                                & \textbf{Contri-} & \textbf{Code}  & \textbf{Start} &                                   &        &        &        &        &        &        &        &        &        &         \\ %\cline{5-6}
                                 &                                & \textbf{butors}  & \textbf{Lines} & \textbf{Year}  &                                   &        &        &        &        &        &        &        &        &        &         \\
                                 &                                &                  &                &                &                                   &        &        &        &        &        &        &        &        &        &         \\ \hline\hline
                                                                                                                                                           % Polar    LDPC     Turbo    TPC      BCH      RS       Conv.    RA       Rep.     Erasure
  {\AFFECT}                      & \cite{Cassagne2019a}           &               11 &            76k & 2016           & MIT                               & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \xmark  \\
  {aicodix GmbH}                 & \cite{Aicodix}                 &                1 &             7k & 2018           & Copyright                         & \xmark & \cmark & \xmark & \xmark & \cmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {eccpage}                      & \cite{ECCpage}                 &               20 &              - & 1989           & -                                 & \xmark & \cmark & \cmark & \xmark & \cmark & \cmark & \cmark & \xmark & \xmark & \cmark  \\
  {EZPWD}                        & \cite{EZPWDRS}                 &                2 &             6k & 2014           & GPLv3                             & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {FastECC}                      & \cite{FastECC}                 &                2 &             1k & 2015           & Apache 2.0                        & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {FEC-AL}                       & \cite{FEC-AL}                  &                1 &             3k & 2018           & BSD                               & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \cmark  \\
  {FECpp}                        & \cite{FECpp}                   &                1 &             2k & 2009           & -                                 & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark  \\
  {GNURadio}                     & \cite{GNURadio}                &              192 &           270k & 2006           & GPLv3                             & \cmark & \cmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \cmark & \xmark  \\
  {Inan}                         & \cite{Inan-LDPC}               &                2 &            13k & 2018           & Copyright                         & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {IT++}                         & \cite{ITpp}                    &               20 &           109k & 2005           & GPLv3                             & \xmark & \cmark & \cmark & \xmark & \cmark & \cmark & \cmark & \xmark & \xmark & \xmark  \\
  {Le Gal}                       & \cite{LeGal-LDPC}              &                1 &            83k & 2015           & -                                 & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {Leopard}                      & \cite{Leopard}                 &                4 &             5k & 2017           & BSD                               & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {libcorrect}                   & \cite{Libcorrect}              &                6 &             5k & 2016           & BSD                               & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \cmark & \xmark & \xmark & \xmark  \\
  {Neal}                         & \cite{Neal-LDPC}               &                1 &             5k & 2006           & Copyright                         & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {OpenAir}                      & \cite{OpenAir}                 &              148 &           740k & 2013           & OAI Public                        & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {OpenFEC}                      & \cite{OpenFEC}                 &                8 &            55k & 2009           & CeCCIL-C                          & \xmark & \cmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {Schifra}                      & \cite{Schifra}                 &                1 &             7k & 2010           & GPLv3                             & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark  \\
  {Siamese}                      & \cite{Siamese}                 &                1 &            11k & 2018           & BSD                               & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \cmark & \xmark & \xmark & \cmark  \\
  {Tavildar (Polar)}             & \cite{Tavildar-Polar}          &                1 &             2k & 2016           & -                                 & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {Tavildar (LDPC)}              & \cite{Tavildar-LDPC}           &                1 &             1k & 2016           & -                                 & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  {the-art-of-ecc}               & \cite{The-art-of-ecc}          &                1 &              - & 2006           & Copyright                         & \xmark & \cmark & \cmark & \cmark & \cmark & \cmark & \cmark & \xmark & \xmark & \xmark  \\
  {TurboFEC}                     & \cite{TurboFEC}                &                2 &             4k & 2015           & GPLv3                             & \xmark & \xmark & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark  \\
  \end{tabular}
  }}
  % \end{adjustbox}
\end{table}

In the digital signal processing community, many scientists implement their own
simulation chain to validate their works.
Table~\ref{tab:fec_libraries_comparison} presents, to the best of our knowledge,
a list of currently available \verb|C|/\Cxx open source channel coding
simulators/libraries. This comparison table is also available
online where it is regularly updated\footnote{\texttt{C}/\Cxx Open Source FEC
Libraries: \url{http://aff3ct.github.io/fec_libraries.html}}. We choose to
compare with projects compiled as binaries, since they aim at high throughput
and low latency, as \AFFECT. Many open source projects in Python or in MATLAB
exist as well, but these tools are usually slower than compiled binaries, and
rather aim at prototyping.

Table~\ref{tab:fec_libraries_comparison} shows that, generally, the
\verb|C|/\Cxx FEC libraries target a single family or a small subset of channel
codes. As a consequence, a large effort is spent to re-develop similar features,
since all those libraries and tools share many characteristics (except the
channel code itself). \AFFECT attempts to lower this redundancy by releasing a
full simulator/library that consistently supports a wide range of channel codes
to the community. \AFFECT also tries to homogenize usage (command line, \Cxx
interfaces, etc.) for all code families.

Note that Table~\ref{tab:fec_libraries_comparison} does not aim at comparing
channel code implementation performances. The implementations of the decoders
will be compared in Chapter~\ref{chap:eval}.

\section{Library of Digital Communication Algorithms}

\subsection{Software Architecture}
\label{sec:aff3ct_archi}

\AFFECT is developed in \Cxx in an object-oriented programming style. It
provides fundamental classes involved in the building of digital communication
chains. These classes are regrouped in the \verb|aff3ct::module| namespace. For
instance, in Fig~\ref{fig:ctx_simu_com_chain}, the source, the encoder, the
modulator, the channel, the demodulator, the decoder and the monitor are module
classes. This type of classes can use sub-blocks that can be common to more than
one module, this sub-blocks are regrouped in the \verb|tools::module| namespace.
The tools can be classes or functions. For instance, the polar API presented in
Section~\ref{sec:opt_polar_api} is a static class implementing the polar $f$,
$g$ and $h$ functions (c.f. Equation~\ref{eq:ctx_polar_f_g_h}) that are common
to all the polar decoders. Thus, the \verb|Polar_API| class is in the
\verb|tools::tools| namespace. As we are in an OOP paradigm, it can exist many
implementations of defined interfaces. For instance, it exists an abstract
\verb|Encoder| class that defines the \verb|encode| pure virtual method. The
\verb|encode| method takes $\bm{u}$ bits of length $K$ as inputs and outputs
$\bm{c}$ bits of size $N$. Then, there are many implementations of the
\verb|Encoder| class like the \verb|Encoder_polar| class, the
\verb|Encoder_LDPC| class, the \verb|Encoder_turbo| class, etc. To simplify the
instanciation of the non-static classes (like the encoders), many factory
classes have been created (for the encoders but not only). This type of classes
are regrouped in the \verb|aff3ct::factory| namespace. Their job is to simplify
the allocation of the module and tool objects.

\subsubsection{Module}

All the classes that are in the \verb|aff3ct::module| namespace inherit from the
\verb|Module| abstract class. The particularity of the module classes is that
they have to expose at least one method that can be called in the context of
digital communication chains. These specific methods are called \emph{tasks}.
For instance, the \verb|Encoder| class inherit from the \verb|Module| class and
defines the \verb|encode| method which is also a task. To be recognized as a
task, the \verb|encode| method has to be registered in the constructor of the
\verb|Encoder| class. The abstract \verb|Module| class defines and implements a
set of functions to perform this registering.

\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{C++}{\curChapter/src/archi/task_registering.cpp}
  \caption{Example of task registering in the \texttt{Encoder} module class.}
  \label{lst:aff3ct_archi_task_registering}
\end{listing}

Listing~\ref{lst:aff3ct_archi_task_registering} presents an example of task
registering. The first step is to call the \verb|create_task| method that
takes the a name as the input parameter (line 8). This name is simply ``encode''
for the \verb|encode| method. Then, the \verb|create_task| method returns a
reference on the created task (\verb|ref_t|). Moreover, the input and output
sockets of the \verb|encode| method defined line 18 have to be declared. The
sockets are used to describe the input and output data of a task. The line 9 and
10 declare two sockets as there are two pointers in the prototype of the
\verb|encode| method. The first one (line 9) is an input socket declaration with
the \verb|create_socket_in| method while the second one (line 10) in an output
socket declaration with the \verb|create_socket_out| method. The socket sizes
and names are set accordingly to the characteristics of the $\bm{u}$ and
$\bm{c}$ vectors. Each time, the \verb|create_socket_x| method returns the id
(\verb|su| and \verb|sc|) of the socket in the task. Finally, a \emph{codelet}
is attached to the task (lines 11-17) thanks to the \verb|create_codelet|
method. This is the actual processing to execute when the task is called. The
purpose of the codelet is to be able to call the \verb|encode| method
independently of the current object instance. The prototype of the codelet is
always \verb|(Module &m, Task &t) -> int|.

Most of the time, when a developer wants to add a new module, he does not need
to register any task because it is already done for him. For instance, if a
developer wants to add a new encoder, he simply needs to inherit from the
proposed \verb|Encoder| class and to implement the \verb|encode| method defined
line 18.

\subsubsection{Tools}

The \verb|aff3ct::tools| namespace regroups many different types of processing.
The following is a synthetic list of the different families of components:
\begin{itemize}
  \item \textbf{Algorithmic \& Math}: the algorithmic components focus on the
    implementation of traditional algorithmic structures. For instance, it
    contains implementations of trees, matrices, histograms, etc. It also
    contains sorting and PRNG algorithms implementations. The math components
    regroup the interpolations, the Galois fields, the distributions, the
    integrations, etc.;
  \item \textbf{Channel code}: this type of tools regroups the processing
    implementations that are common to a single code family. For instance, the
    \verb|Polar_API| is located here;
  \item \textbf{Display}: these components are classes and functions dedicated
    to the display of the information in the terminal or in files. Statistic
    functions are located here as well as classed dedicated to the display of
    the BER and the FER performances;
  \item \textbf{Interface}: these abstract classes define interfaces. For
    instance, the \verb|Interface_reset| proposes a common interface for the
    \verb|reset| method. This way, all the classes inhering from this interface
    have exactly the same prototype for their implementation of the \verb|reset|
    method;
  \item \textbf{Performance}: this type of components is dedicated to high
    performance implementation. The vectorized reordering process presented in
    Section~\ref{sec:opt_vec_inter} is located here.
\end{itemize}
The above list is not exhaustive but is intended to give a representative
overview of what can be found in the tools.

\subsubsection{Factory}

In the OOP paradigm, the factory method pattern is dedicated to the the problem
of creating objects without having to specify the exact class of the object that
will be created. This is done by calling a method on the factory. In \AFFECT,
all the factories propose a \verb|build| method to this purpose. The return type
of the \verb|build| method is always an abstract class that regroups a sub-set
of implemented classes. Considering the \verb|factory::Source| class, first the
instantiation of this class is required. Then, the created object comes with a
list of public members that can be manually set or deduced from the command line
arguments. Once it is done the \verb|build| method can be called. This method
uses the public members (previously set) of the object to instantiate an object
of the \verb|module::Source| class. This object can be a
\verb|moudle::Source_random| object, a \verb|module::Source_user_binary| object,
etc.

\subsection{Software Functionalities}
\label{sec:aff3ct_features}

The \AFFECT software functionalities can be decomposed in three main parts: the
\textit{codecs}, the \textit{modems} and the \textit{channels}.

\begin{table}[htp]
  \centering
  \caption{List of the channel codes (codecs) supported in \AFFECT.}
  \label{tab:aff3ct_features_codecs}
% {\footnotesize%\resizebox{\linewidth}{!}{
  \begin{tabular}{ c | c | c }
  \multirow{2}{*}{\textbf{Channel Code}}  & \multirow{2}{*}{\textbf{Standard}} & \multirow{2}{*}{\textbf{Decoders}}        \\
                                          &                                    &                                           \\
  \hline
  \hline
  \multirow{5}{*}{{LDPC}}                 & 5G (data), Wi-Fi,                  & Scheduling: Flooding and H./V. Layered    \\
                                          & WiMAX, WRAN,                       & Sum-Product Algorithm (SPA, log-SPA)      \\
                                          & 10 Gigabit Eth.,                   & Min-Sum its derivatives (MS, NMS and OMS) \\
                                          & DVB-S2, CCSDS                      & Approximate Min-Star (AMS)                \\
                                          & etc.                               & Bit Flipping: GallagerA/B/E, PPBF, WBF    \\
  \hline
                                          &                                    & Successive Cancellation (SC)              \\
  Polar                                   & 5G                                 & Successive Cancellation List (SCL)        \\
  (\Arikan mono-kernel)                   & (control channel)                  & CRC-Aided SCL (CA-SCL, FA-SCL, PA-SCL)    \\
                                          &                                    & Soft Cancellation (SCAN)                  \\
  \hline
  Polar                                   &                                    & Successive Cancellation (SC)              \\
  (mono/multi-kernel                      & --                                 & Successive Cancellation List (SCL)        \\
  generic)                                &                                    & CRC-Aided SCL (CA-SCL, PA-SCL)            \\

  \hline
  \multirow{1}{*}{{Turbo Parallel}}       & LTE (3G, 4G),                      & Turbo BCJR                                \\
  (single and double                      & DVB-RCS,                           & Turbo BCJR + Early Termination (CRC)      \\
  binary)                                 & CCSDS, etc.                        & Post proc.: Flip aNd Check (FNC)          \\
  \hline
  \multirow{2}{*}{{Turbo Product}}        & \multirow{2}{*}{WiMAX (opt.)}      & \multirow{2}{*}{Turbo Chase-Pyndiah}      \\
                                          &                                    &                                           \\
  \hline
  \multirow{3}{*}{{BCH}}                  & CD, DVD,                           &                                           \\
                                          & SSD, DVB-S2,                       & Berlekamp-Massey + Chien search           \\
                                          & Bitcoin, etc.                      &                                           \\
  \hline
  \multirow{3}{*}{{Reed-Solomon}}         & CD, DVD,                           &                                           \\
                                          & SSD, DVB-T,                        & Berlekamp-Massey + Chien search           \\
                                          & ADSL, etc.                         &                                           \\
  \hline
  \multirow{1}{*}{{Convolutional}}        &                                    & BCJR - Maximum A Posteriori (MAP)         \\
  (single and double                      & NASA                               & BCJR - Linear Approximation (L-MAP)       \\
  binary)                                 &                                    & BCJR - Max-log Approximation (ML-MAP)     \\
  \end{tabular}
% }%}
\end{table}

The codecs are the main part of the toolbox. There is a broad range of supported
codes listed in Table~\ref{tab:aff3ct_features_codecs}. They naturally encompass
the encoders and decoders, but they can also include puncturing patterns to
shorten frames length according to some communication standards. Most of the
codec algorithms come from the literature, while the others have been designed
under \AFFECT~\cite{Tonnellier2016a,Tonnellier2016b,Tonnellier2017,
Leonardon2019}. In channel coding, the decoder is the most time-consuming
process, compared to the puncturing and the encoding processes. This is why a
specific effort is put on ensuring the high computing performance of the
decoders. Most of the decoding algorithms have thus been optimized to satisfy
high throughput and low latency constraints~\cite{LeGal2015a,Cassagne2015c,
Cassagne2016a,Cassagne2016b}. Those optimizations generally involve a vectorized
implementation, a tailored data quantization and the use of fixed-point
arithmetic.

\begin{table}[htp]
  \centering
  \caption{List of the modulations/demodulations (modems) supported in \AFFECT.}
  \label{tab:aff3ct_features_modems}
  %{\footnotesize%\resizebox{\linewidth}{!}{
  \begin{tabular}{ c | c | c }
  \multirow{2}{*}{\textbf{Modem}} & \multirow{2}{*}{\textbf{Standard}} & \multirow{2}{*}{\textbf{Information}}  \\
                                  &                                    &                                        \\
  \hline
  \hline
  \multirow{3}{*}{{N-PSK}}        & IEEE 802.16 (WiMAX)                &                                        \\
                                  & UMTS (2G, 2G+)                     & Phase-Shift Keying                     \\
                                  & EDGE (8-PSK), ...                  &                                        \\
  \hline
  \multirow{3}{*}{{N-QAM}}        & IEEE 802.16 (WiMAX)                &                                        \\
                                  & UMTS (2G, 2G+)                     & Quadrature Amplitude Modulation        \\
                                  & 3G, 4G, 5G, ...                    &                                        \\
  \hline
  \multirow{3}{*}{{N-PAM}}        & IEEE 802.16 (WiMAX)                &                                        \\
                                  & UMTS (2G, 2G+)                     & Pulse Amplitude Modulation             \\
                                  & 3G, 4G, 5G, ...                    &                                        \\
  \hline
  \multirow{2}{*}{{CPM}}          & GMSK, Bluetooth                    & Continuous Phase Modulation            \\
                                  & IEEE 802.11 FHSS                   & Coded (convolutional-based) modulation \\
  \hline
  \multirow{2}{*}{{OOK}}          & IrDA (Infrared)                    & On-Off Keying                          \\
                                  & ISM bands                          & Used in optical communication systems  \\
  \hline
  \multirow{2}{*}{{SCMA}}         & \multirow{2}{*}{Considered for 5G} & Sparse Code Multiple Access            \\
                                  &                                    & Multi-user modulation                  \\
  \hline
  \multirow{2}{*}{{User defined}} & \multirow{2}{*}{-}                 & Constellation and order can be         \\
                                  &                                    & defined from an external file          \\
  \end{tabular}
  %}%}
\end{table}

In typical communication chains, it is necessary to adapt the digital signal
to the physical support. This operation is performed by the modulator and
conversely by the demodulator. \AFFECT comes with a rich set of modems to this
purpose. Table~\ref{tab:aff3ct_features_modems} lists all the supported modems.
\AFFECT supports several coded modulation/demodulation schemes like the
Continuous Phase Modulation (CPM)~\cite{Aulin1981a,Aulin1981b} and the Sparse
Code Multiple Access (SCMA) modulation~\cite{Nikopour2013,Ghaffari2017,
Ghaffari2019} (many codebooks are supported~\cite{AlteraSCMA,Wu2015,Cheng2015,
Zhang2016,Klimentyev2016,Song2017,Klimentyev2017}). It allows to easily combine
and evaluate the channel codes with several types of modulations. In the case of
the CPM, analogical wave shapes are also simulated. The other modulation schemes
are at the digital level.

\begin{table}[htp]
  \centering
  \caption{List of the channel models supported in \AFFECT.}
  \label{tab:aff3ct_features_channels}
  % {\footnotesize%\resizebox{\linewidth}{!}{
  \begin{tabular}{ c | c | c }
  \multirow{2}{*}{\textbf{Channel}}      & \multirow{2}{*}{\textbf{Multi-user}} & \multirow{2}{*}{\textbf{Information}}          \\
                                         &                                      &                                                \\
  \hline
  \hline
  \multirow{2}{*}{{AWGN}}                & \multirow{2}{*}{Yes}                 & \multirow{2}{*}{Additive White Gaussian Noise} \\
                                         &                                      &                                                \\
  \hline
  \multirow{2}{*}{{BEC}}                 & \multirow{2}{*}{No}                  & \multirow{2}{*}{Binary Erasure Channel}        \\
                                         &                                      &                                                \\
  \hline
  \multirow{2}{*}{{BSC}}                 & \multirow{2}{*}{No}                  & \multirow{2}{*}{Binary Symmetric Channel}      \\
                                         &                                      &                                                \\
  \hline
  \multirow{2}{*}{{Rayleigh}}            & \multirow{2}{*}{Yes}                 & \multirow{2}{*}{Flat Rayleigh fading channel}  \\
                                         &                                      &                                                \\
  \hline
  \multirow{2}{*}{{User defined}}        & \multirow{2}{*}{No}                  & User can import noise samples                  \\
                                         &                                      & from an external file                          \\
  \end{tabular}
  %}%}
\end{table}

For simulation purposes, it is crucial to emulate the behavior of the physical
layer. This is the role of the channel. There are many possible configurations
depending on the physics phenomena to simulate.
Table~\ref{tab:aff3ct_features_channels} reports all the supported channels. The
channels involve complex floating-point computations. It is frequent to use
exponential and trigonometric operations. Those types of operations cost a large
amount of CPU cycles to be computed. As for the decoders, the channels have been
carefully optimized based on branch instructions reduction and massive
vectorization.

Many additional functional functionalities available are skipped here for
concision.

\subsection{Example of Library Use}
\label{sec:aff3ct_library_example}

As a FEC library, \AFFECT can be used programmatically, for instance in
real-time contexts or to build specific functional simulations. \AFFECT blocks
can be used in external projects without restriction. Compute intensive blocks
are optimized and vectorized to run fast on a single core.

% The library is thread-safe; however, it is not multi-threaded by itself, in
% contrast to the simulator. Instead, it is the responsibility of the user to
% manage multi-threading.

\begin{figure}[htp]
  \centering
  \includegraphics{\curChapter/fig/use_cases/library_task_module/library_task_module}
  \caption{Simulation of a digital communication chain using the \AFFECT
    library.}
  \label{fig:aff3ct_library_task_module}
\end{figure}

In this section we propose an illustrative example of the \AFFECT library
utilization. The objective is to simulate the digital communication chain shown
in Figure~\ref{fig:aff3ct_library_task_module}. In the figure, the represented
modules correspond to the classes presented in the previous section. A module
can also be seen as a set of related tasks sharing some characteristics. For
instance, the \textit{modem} module contains the \textit{modulate} and
\textit{demodulate} tasks. Then, a task is an elementary processing performed on
some data. For instance, \textit{decode} or \textit{modulate} are tasks. The
tasks are characterized by their \textit{sockets}. A socket of a task defines an
entry point through which the task will consume and/or produce data. There are
three kinds of sockets: \textit{input}, \textit{output} and
\textit{input/output}, following a philosophy close to \emph{ports} in
component-based development approaches. As a rule, a task is always a
\emph{verb} and a module is always a \emph{noun}.
Figure~\ref{fig:aff3ct_library_task_module} presents common modules and tasks
typically found in a basic communication chain. It shows that the number of
tasks per module can vary depending on the module type.

\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{C++}{\curChapter/src/use_cases/library/modules_allocation.cpp}
  \caption{Example of modules allocation with the \AFFECT library.}
  \label{lst:aff3ct_library_modules_allocation}
\end{listing}

The first step is to allocate the modules. In
Listing~\ref{lst:aff3ct_library_modules_allocation} we chose to allocate modules
on the stack, but it is also possible to do the same on the heap. $K$ is the
number of information bits, $N$ is the frame size and $E$ is the number of
erroneous frames to simulate. In this basic example, a repetition code is
selected, it simply repeats the information bits $N/K$ times.

\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{C++}{\curChapter/src/use_cases/library/sockets_binding.cpp}
  \caption{Example of sockets binding with the \AFFECT library.}
  \label{lst:aff3ct_library_sockets_binding}
\end{listing}

The next step is to bind the sockets of successive tasks together (see
Listing~\ref{lst:aff3ct_library_sockets_binding}): The \textit{source} module
output socket \verb|module::src::sck::generate::u| is connected to the input
socket \verb|module::enc::sck::encode::u| of the \textit{encoder}, and so
on, for all the sockets of the tasks.

\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{C++}{\curChapter/src/use_cases/library/tasks_execution.cpp}
  \caption{Example of tasks execution with the \AFFECT library.}
  \label{lst:aff3ct_library_tasks_execution}
\end{listing}

The simulation is then started and each task is executed. In
Listing~\ref{lst:aff3ct_library_tasks_execution}, the whole communication chain
is executed multiple times, until the $E = 100$ frame error limit is achieved.

To propose an easy to use interface, sockets and tasks can be selected through
the \verb|[]| operator, which takes a \Cxx strongly typed enumerate. This way it
is possible to specialize the code depending on whether it is a socket or a
task. Strongly typed enumerates are checked at compile time (contrary to
standard enumerates), making it impossible to use wrong values. Complete
examples of the \AFFECT library utilization are available on
GitHub\footnote{\AFFECT library examples: \url{https://github.com/aff3ct/my_project_with_aff3ct/}}.

The \AFFECT library has also been used to prototype FPGA decoders.
In~\cite{Cassagne2017a}, a BCH decoder is implemented on a Xilinx\R Artix-7
FPGA. \AFFECT simulates the transmission of a first frame. The noisy frame is
then sent to the FPGA using the UART protocol. The hardware BCH decoder
processes the frame and sends it back to the PC. \AFFECT can then proceed and
perform the rest of the processing for this frame. Once the number of residual
errors is updated, \AFFECT starts with a new frame, and so on. The decoding
performance appears to be equivalent to the performance of the pure software
simulation which shows that the hardware BCH decoder is correctly implemented.

\subsection{MATLAB Wrapper}

In the signal processing community it is common to use MATLAB to implement and
to evaluate new algorithms or/and configurations. More specifically, the
\emph{communications toolbox} is often used. This toolbox contains a large set
of algorithms of digital communication systems but they often lack of
efficiency, especially for the channel decoder implementations. Knowing that,
we developed a wrapper MATLAB to enable calls to the compiled \AFFECT library.
The wrapper can be seen as a new MATLAB toolbox that proposes faster decoder
implementations than the traditional MATLAB communications toolbox. \AFFECT
also comes with channel decoders that are not available in the standard
communications toolbox.

The proposed MATLAB wrapper is automatically generated for the \AFFECT headers.
The Clang compiler is used to generate the Abstract Syntax Tree (AST) of the
\AFFECT source code and a Python script extracts useful classes and methods.
These data are stored in a JSON database. Then, an other Python script as been
written to generate \Cxx and MATLAB codes that effectively perform the interface
between the \AFFECT library and MATLAB.
At the time of the writing, the MATLAB wrapper has not been released yet.

\section{Simulation of Digital Communication Algorithms}

\subsection{Example of Simulator Use}
\label{sec:aff3ct_simulator_example}

The \AFFECT toolbox comes with a dedicated functional
simulator~\cite{Cassagne2017}. It is based on the \AFFECT library presented
before. We remarked that the functional simulation chain used in the literature
are very often similar. For this reason, the simulation chain presented in
Fig.~\ref{fig:aff3ct_library_task_module} has been enriched and implemented. The
proposed simulator supports multi-threading to take advantage of the today CPUs
multi-core architecture. It is also able to run on supercomputers and comes with
a multi-node implementation based on the well-known HPC Message Passing
Interface (MPI). The multi-core and multi-node performance of the \AFFECT
simulator will be evaluated later in Section~\ref{sec:eval_simu}.

One of the main advantage of the \AFFECT simulator is to come with a common
interface for many channel code families. It is also possible to evaluate the
error-rate performance of these code families on various configurations thanks
to the supported modems and channel models. It also becomes easier to compare
different code families with each other.

\begin{listing}[htp]
  \inputminted[frame=lines]{bash}{\curChapter/src/use_cases/simulator/input.txt}
  \caption{Example of an \AFFECT simulator command.}
  \label{lst:aff3ct_simulator_input}
\end{listing}

The \AFFECT simulator is a command line executable and all its possible
parameters are exhaustively documented\footnote{\AFFECT documentation:
\url{https://aff3ct.readthedocs.io}}. Listing~\ref{lst:aff3ct_simulator_input}
proposes to simulate a $(2048,1723)$ polar code from 1 dB to 4 dB with a step of
1 dB (c.f. Section~\ref{sec:ctx_simulation}). By default, the AWGN channel is
selected as well as the BPSK modulation. Then the SC decoder is specified. For a
given SNR, by default the simulation stops when more than 100 erroneous frames
are detected.

\begin{listing}[htp]
  \inputminted[frame=lines,linenos]{console}{\curChapter/src/use_cases/simulator/output.txt}
  \caption{Example of an \AFFECT simulator output.}
  \label{lst:aff3ct_simulator_output}
\end{listing}

Listing~\ref{lst:aff3ct_simulator_output} shows the simulation results
corresponding to the \AFFECT command given in
Listing~\ref{lst:aff3ct_simulator_input} (note that some details have been
removed for concision). \verb|FRA| stands for the number of simulated frames,
while \verb|BE| and \verb|FE| are the number of bit and frame errors. The
simulator output is clear and adapted to post processing: lines starting with a
hashtag can be skipped.

\subsection{Exhaustive Exploration}

% TODO: mettre les courbes de BER/FER ici, faire une discussion sur
%       l'exploration possible

\subsection{BER/FER Comparators} % Pre-simulated Results?

% TODO: des chiffres des chiffres Ã  dit Denis

The \AFFECT output (c.f. Listing~\ref{lst:aff3ct_simulator_output}) is not
adapted to see the error-rate performance at a glance. And it is even more
complicated to compare two or more simulation outputs with each other.
Traditionally the BER and FER decoding performances are presented in a form of
graphical curves (c.f. Fig.~\ref{fig:ctx_bfer}). It is then much easier to
compare their performances.

To this purpose, a portable tool named \emph{PyBER} has been developed.
This tool is a standalone program written in Python. It is capable to read the
\AFFECT simulator outputs but it can also easily adapt to other formats. PyBER
extensively uses the \emph{PyQtGraph} library to plot the BER/FER curves. PyBER
allows to browse the file system and to select one or more text files to
display. It is also possible to zoom on the curves and the simulation details of
each curve are presented in a dedicated panel. PyBER can plot in real-time the
curves that are currently simulated (there is no need to reload the \AFFECT
output files). Like all the \AFFECT tools, PyBER is open-source and can be used
without any limitations\footnote{PyBER repository:
\url{https://github.com/aff3ct/PyBER}}.

Recently, a new BER/FER comparator has been introduced. It is available online
on the \AFFECT website\footnote{\AFFECT online BER/FER comparator:
\url{http://aff3ct.github.io/comparator.html}}. This comparator comes with the
same features as PyBER but it is written in JavaScript. By default, a database
of \AFFECT simulated results is already available. This database is the same as
the error-rate reference results used in the regression tests of the CI.
Then, these references are classified according to different characteristics:
the code type, the modem type, the channel type, the frame size ($N$) and the
code rate ($R$). There is also a search bar to facilitate the curves selection
process. At the time of the writing, approximatively 500 references are
available. For each reference, it possible to get the corresponding command line
in the \AFFECT simulator. This way it is very easy to reproduce the reference
results or to modify the command line parameters. The reference curves that have
been published are marked with the DOI of the publication. It is then possible
to search a specific result from its DOI in the search bar. Note that with the
online BER/FER comparator it is very easy to share the selected curves with
other people thanks to a permalink. The default proposed database is the
\AFFECT database (error-rate references) but it is also possible to enable the
database of the Kaiserslautern University. We wrote a script to automatically
parse their online database\footnote{Kaiserslautern ML BER/FER database:
\url{https://www.uni-kl.de/channel-codes/ml-simulation-results/}}. Otherwise it
is still possible to load BER/FER references from local files. Many text formats
are supported.

\subsection{Continuous Integration and Continuous Delivery}
\label{sec:aff3ct_ci_cd}

\AFFECT's development leverages streamlined Continuous Integration (CI) process.
Each new commit the version control repository (Git) triggers a comprehensive
sequence of tests to catch potential regressions. These tests are combined with
Continuous Delivery (CD) tasks to deliver new \AFFECT builds automatically.

\begin{figure}[htp]
  \centering
  \includegraphics{\curChapter/fig/ci_cd/pipeline/pipeline}
  \caption{\AFFECT continuous integration and continuous delivery pipeline.}
  \label{fig:aff3ct_ci_cd_pipeline}
\end{figure}

Fig.~\ref{fig:aff3ct_library_task_module} shows the different stages of the
\AFFECT CI/CD pipeline. The \emph{analysis} stage contains jobs that can be
executed without compiling the \AFFECT binaries. The \emph{build} stage is a set
of compilation jobs. The \emph{check} stage proposes verification jobs that
require the \AFFECT binaries. The \emph{test} stage is composed by a set of jobs
focusing on regression testing . The \emph{coverage} stage measures the
percentage of the \AFFECT source code used in the regression tests. Finally, the
\emph{Deploy} stage contains jobs that are used to push the pipeline results on
various targets.

\paragraph{Analysis}

In this stage, static analysis tools are run on the \AFFECT source code
in order to get some metric on the code quality. To this purpose
\textit{cppcheck}, \textit{scan-build} and \textit{clang-tidy} are used. This
stage also contains a job dedicated to the compilation of the documentation,
this documentation will later be packed in the deployed builds if the pipeline
succeed. Moreover, a script dedicated to the \AFFECT headers is also executed as
well as a script that check if the Git sub-modules are valid. The execution time
of the analysis stage is relatively short. If one of the jobs fails, then the
pipeline stop.

\paragraph{Build}

The main purpose of the build stage are: 1) verify that the \AFFECT source code
compiles on many compilers and operating systems; 2) compile static and portable
binaries to deliver new builds at the end of the pipeline. On Windows, the GNU
compiler and the Microsoft Visual compiler are tested. On Linux, the GNU
compiler, the Clang compiler, and the Intel compiler are  tested. On macOS, only
the Clang compiler is tested at this time. Specific SSE4.2 and AVX2 static
binaries are compiled for the 3 operating systems.

\paragraph{Check}

In the check stage, the \emph{debug-parser} tool is verified on the compiled
\AFFECT binaries. This tool is a Python script that post-process the \AFFECT
simulation debug output to show the contain of the data between the tasks. A
second job checks if the documentation is compatible with the help of the
\AFFECT simulator binary. A Python script checks that the entries in the
documentation corresponds to the one present in the simulator help to prevent
from desynchronization.

\paragraph{Test}

The regression tests are split according to the different channel code families.
Each job focuses on a single family of code. Error-rate reference results that
have been recorded from previous simulations are replayed. A Python script
compares the reference results with the current simulator outputs. If the
references and the current outputs are close enough, then the tests are
validated. This tests are very important and ensure that the previously
implemented features are still working after many source code modifications.
When a developer add a new feature it is to its responsibility to add the
corresponding regression tests in the CI.

\paragraph{Coverage}

To compute the code coverage, the GNU compiler \verb|--coverage| option combined
to the \emph{gcov} tool are used. A specific \AFFECT simulator binary is
compiled and run on all the error-rate references. To reduce the execution time,
only one frame per SNR is simulated. At the time of the writing, the regression
tests are covering about 60\% of the \AFFECT source code.

\paragraph{Deploy}

The deploy stage is in charge to regroup the \AFFECT compiled binaries
(simulator and library) with the documentation, the error-rate references, some
configuration files, etc. There are two builds for each operating system, one in
SSE4.2 and the other in AVX2. Once the build is ready, an entry in the \AFFECT
website is automatically added, committed and pushed. Then the users can
directly download the last builds on the \AFFECT download page\footnote{\AFFECT
download page: \url{http://aff3ct.github.io/download.html}}. An other job is in
charge to push the \AFFECT build on our Ubuntu Personal Package Archives
(PPA)\footnote{\AFFECT Ubuntu PPA: \url{https://launchpad.net/~aff3ct/+archive/ubuntu/aff3ct-dev}}.
Once the \AFFECT PPA is added to the Ubuntu system, then it is trivial to
install the last \AFFECT builds
(\verb|sudo apt install aff3ct-bin aff3ct-doc libaff3ct libaff3ct-dev|). Only
the SSE4.2 build is pushed to the Ubuntu PPA as it maximizes the number of
laptops that can execute it. Finally, a last job send the various static
analysis and code coverage reports to a SonarQube instance\footnote{\AFFECT
SonarQube: \url{https://sonarqube.inria.fr/sonarqube/dashboard?id=storm:aff3ct:gitlab:master}}.
SonarQube is a web control panel for the quality of the source code.

The \AFFECT pipeline instances are publicly available online\footnote{\AFFECT
pipelines: \url{https://gitlab.com/aff3ct/aff3ct/pipelines}}. The CI/CD process
enables us to safely and confidently integrate contributed features and
improvements from the community to \AFFECT. It also helps to keep the code
review time by the core development team low-enough to swiftly integrate such
contributions into the master branch.

\section{Impact and Community}
\label{sec:aff3ct_impact}

\AFFECT is currently used in several industrial contexts for simulation purposes
(Turbo concept, Airbus, Thales, Huawei) and for specific developments (CNES,
Schlumberger, Airbus, Thales, Orange), as well as in academic projects (NAND
French National Agency project, IdEx CPU). The MIT license used in the project
is very permissive and gives confidence to industrial and academic partners, who
can then invest themselves and reuse parts of \AFFECT in their own projects
without any restrictions.

% TODO: regrouper les citations par thÃ©matiques

\AFFECT has been cited in scientific publications and this paragraph aims to
give an overview of its utilization. In~\cite{Leonardon2018a} the \AFFECT fast
software SC decoders (c.f. Section\ref{sec:opt_polar}) are compared to an
Application Specific Instruction Set Processor (ASIP). In~\cite{Leonardon2018b}
the proposed P-EDGE generator (c.f. Section~\ref{sec:opt_polar_pedge}) has been
enriched to generate Transport Triggered Architecture (TTA $\approx$ VLIW)
instructions. Then the generated TTA polar decoders are compared to the \AFFECT
generated software polar decoders. In~\cite{Florian2018}, the cross-platform
PHYSIM software framework is proposed. This framework encapsulates the \AFFECT
channel encoders and decoders and combines them to complex modulation schemes.
In~\cite{Pignoly2018,Ghanaatian2018,Wang2019} high speed hardware decoders are
proposed and their error-rate performances are validated by using the \AFFECT
simulator error-rate results as a reference. In~\cite{Poulenard2018}, \AFFECT is
used to evaluate various channel codes error-rate performances before to propose
a framework to jointly design interleaving and FEC schemes for free space
optical link. In~\cite{Cavatassi2019a,Cavatassi2019b} the \AFFECT implementation
of the Gaussian Approximation (GA) method has been used. This method allows to
decide the frozen bits location in the polar codes. In~\cite{Cenova2019}, the
SIMD implementations of the \AFFECT decoders are considered for the High-Level
Synthesis (HLS) of ASICs. It is shown that, at this time, the HLS tools are not
able to directly take advantage of the \Cxx SIMD software implementations.
In~\cite{Guermouche2019}, \AFFECT is considered as one of the benchmark
applications as it heavily relies on the SIMD units. The performance behavior of
\AFFECT is studied depending on various SIMD ISAs. In~\cite{Wang2019} a new
concatenation scheme of BCH-Polar codes is proposed. The \AFFECT simulator has
been modified to support this new coding scheme and used to validate its
error-rate performance. In~\cite{Krainyk2019}, the work gives new procedures and
software models to simplify the development of the turbo product codes. The
authors find that \AFFECT is not adapted as it is complicated to see the
evolution inside the TPC decoder. In~\cite{Hsieh2020,Rush2020} a generalization
of sparse superposition of channel codes is studied. In this context, \AFFECT is
used to compare the decoding performance of this new method with more
traditional schemes (LDPC + QAM). In~\cite{Tasdighi2020}, a new LDPC code
construction method is proposed. The decoding performances are evaluated through
\AFFECT.

As \AFFECT is open-source, some of the previous works has been integrated inside
the toolbox. However, it worth mentioning that \AFFECT is more often simply used
than enriched. But, we believe that the proposed philosophy can lead to a
growing community of contributors. We also know that bigger open-source
projects, like GNU Radio, are considering to integrate some of the \AFFECT fast
decoders.

\section{Discussion}
